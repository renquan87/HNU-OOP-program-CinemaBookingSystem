# 电影院订票系统 - 后端详细讲解（Java / Spring Boot，新手向）

> 目标：让你能从“启动程序”开始，理解每一个 HTTP 请求在后端经历了什么：Controller 接收 → Service 处理业务 → Storage 读写 MySQL → 返回 JSON；并理解项目里“锁座”“订单状态”“定价策略”“WebSocket 推送”等关键机制。

---

## 1. 后端技术栈与整体结构

### 1.1 技术栈

- **Java 17**：语言与运行环境
- **Spring Boot 2.7.5**：Web 后端框架（提供 MVC、依赖注入、自动配置等）
- **Spring MVC**：REST API（`@RestController`）
- **JDBC + MySQL**：数据持久化（项目里自行封装了连接工具 + SQL）
- **WebSocket（javax.websocket）**：实时推送座位变更（同一场次多人选座实时刷新）
- **Maven**：依赖管理与构建

### 1.2 典型分层（非常重要）

你可以把后端按职责分成 4 层：

```
客户端（浏览器）
  ↓ HTTP / WebSocket
Controller（控制器层：接收请求、校验参数、拼响应）
  ↓ 调用
Service（业务层：订票规则、锁座、订单状态、定价策略）
  ↓ 调用
Storage（数据层：JDBC 读写 MySQL，把对象存进表里）
  ↓ SQL
MySQL（数据库）
```

在本项目里：

- `com.cinema.controller`：控制器（API入口）
- `com.cinema.service`：核心业务（`CinemaManager`、`BookingService` 等）
- `com.cinema.storage`：数据库访问（`MySQLDataStorage`、`SimpleDatabaseConnection`）
- `com.cinema.model`：实体模型（Movie/Show/Seat/Order/User…）
- `com.cinema.strategy`：策略模式（定价策略）
- `com.cinema.ws`：WebSocket 服务端（推送座位刷新）
- `com.cinema.config`：Spring 配置（拦截器、WebSocket 注册、响应配置）

---

## 2. 程序如何启动？（从 main 到能提供 API）

### 2.1 Spring Boot 入口：CinemaApplication

后端启动类是 `com.cinema.CinemaApplication`（`main` 方法）。

它做了一件对新手非常关键的事：**在 Spring Boot 启动前，手动初始化了遗留的单例服务**。

原因是：项目里业务层用了“传统单例”（`getInstance()`），如果不提前初始化，Controller 调用时可能会出现“未初始化”的异常。

启动顺序概念化如下：

1. **设置数据库连接参数**（把命令行参数传进去，用于加载 DB 密码）
2. **初始化 BookingService（注入定价策略）**
3. **初始化 CinemaManager（加载电影/影厅/场次/用户等）**
4. **启动 Spring Boot**（开始监听端口、接收请求）

### 2.2 端口与 HTTP 基础配置：application.properties

项目后端端口是 **8081**（`server.port=8081`）。

另外还做了与前端代理相关的“响应/编码”调整，例如：

- 禁用 HTTP2：`server.http2.enabled=false`
- 禁用压缩：`server.compression.enabled=false`
- 强制 UTF-8 编码：避免中文乱码

这些配置的目的：**修复 Vite 代理时出现的分块编码问题**（前端代理报错 `Expected LF after chunk data` 之类）。

---

## 3. 数据库与配置：MySQL 如何连接、如何初始化表？

### 3.1 数据库连接配置：config.properties

资源文件 `config.properties`（在 `src/main/resources`）定义了：

- `db.url`：JDBC 地址（默认 `cinema_db`）
- `db.username`：用户名（默认 root）
- `db.password`：**刻意留空**（避免把密码提交到仓库）

项目推荐通过 **环境变量 `DB_PASSWORD`** 提供密码。

### 3.2 密码读取优先级：DbPasswordResolver

密码读取顺序（优先级从高到低）：

1. 环境变量 `DB_PASSWORD`
2. 命令行参数（第一个参数）
3. `config.properties` 里的 `db.password`
4. 都没有则使用默认密码（代码里会打印警告）

这在本项目里由 `com.cinema.config.DbPasswordResolver` 统一实现。

### 3.3 数据库初始化：DatabaseInitializer + schema.sql

项目提供了 `com.cinema.DatabaseInitializer`，可以执行：

- 连接 MySQL 服务器
- 创建数据库 `cinema_db`
- 执行 `schema.sql` 建表
- 插入一些初始数据（电影/用户/影厅/场次）

`schema.sql` 会创建主要表：

- `movies` 电影
- `comments` 评论
- `screening_rooms` 放映厅
- `shows` 场次
- `users` 用户
- `orders` 订单
- `order_seats` 订单-座位关联

注意：脚本中对 `users` 做了“保留用户数据”的处理：

- `DROP TABLE` 时注释掉了 users
- `CREATE TABLE IF NOT EXISTS users`（不存在才创建）

这意味着：重新初始化库时，用户表可能被保留（便于演示）。

### 3.4 JDBC 连接工具：SimpleDatabaseConnection

`com.cinema.storage.SimpleDatabaseConnection` 的职责是：

- 读取 `config.properties`
- 解析密码（调用 DbPasswordResolver）
- `Class.forName(driver)` 加载驱动
- `DriverManager.getConnection(...)` 获取连接

你可以把它理解成一个“最简 JDBC 连接工厂”。

---

## 4. 模型层（Model）：后端到底在操作什么对象？

这一层非常像你在 OOP 课里学到的“领域对象”。

### 4.1 Seat（抽象座位）与 SeatStatus

`Seat` 是抽象类，有：

- `row` / `col`：座位坐标
- `basePrice`：该座位价格（会被定价策略计算后写入）
- `status`：座位状态

座位状态 `SeatStatus`：

- `AVAILABLE`：可购买
- `LOCKED`：已锁定（有人下单/预订但未支付）
- `SOLD`：已售出

并提供：

- `lock()` / `unlock()` / `sell()`

座位 id 统一用：`row-col`，例如 `1-1`。

### 4.2 Order（订单）与 OrderStatus

`Order` 代表一次购票行为，包含：

- `orderId`
- `show`：对应的场次
- `seats`：座位列表
- `user`：下单用户
- `createTime`
- `lockTime`：预订锁定时间（用于 15 分钟过期）
- `status`：订单状态

订单状态：

- `PENDING`：待支付（createOrder 创建）
- `RESERVED`：预留（reserveOrder 创建，通常会锁 15 分钟）
- `PAID`：已支付
- `CANCELLED`：取消
- `REFUNDED`：退票
- `EXPIRED`：过期

订单里有：

- `calculateTotal()`：把 seats 的 basePrice 求和
- `isExpired()`：`RESERVED` 且超过 15 分钟视为过期

### 4.3 Show / Movie / ScreeningRoom / User 的关系

简单理解：

- `Movie`（电影）有多个 `Show`（场次/排片）
- `Show` 在某个 `ScreeningRoom`（影厅）播放
- `Show` 有一堆 `Seat`（座位）
- `User` 可以创建多个 `Order`（订单）

这就是典型 OOP 建模：对象之间有关联关系。

---

## 5. 数据层（Storage）：对象怎么存进 MySQL？

### 5.1 MySQLDataStorage 的核心思想

`com.cinema.storage.MySQLDataStorage` 负责把内存中的对象（Map 里的 Movie/Show/User…）写入数据库表，并能从表里读出来恢复对象。

它使用的就是**JDBC**：

- `Connection`
- `PreparedStatement`
- `ResultSet`

并且对批量保存做了：

- `conn.setAutoCommit(false)`
- `addBatch()`
- `executeBatch()`
- `commit()`

这是“批处理”写法，效率比逐条 insert 高。

### 5.2 电影存取与评论（Movies + Comments）

保存电影时使用 `INSERT ... ON DUPLICATE KEY UPDATE`：

- 电影 id 是主键
- 如果已存在则更新字段

并且它会在保存电影后**顺便保存评论**（`saveComments(movies)`）。

加载电影时：

1. 先 load movies
2. 再 load comments
3. 把评论挂回到对应的 Movie 对象上

这是典型的“分表加载 + 组装对象”。

### 5.3 场次存取（Shows）与时间格式

项目统一使用 `yyyy-MM-dd HH:mm:ss` 作为 DB 中时间字符串格式（DATE_FMT）。

保存 show 时会额外写入 end_time：

- `end_time = start_time + movie.duration`

这就是“由业务推导字段”的例子。

---

## 6. 业务层（Service）：系统的规则都在这里

### 6.1 CinemaManager：像一个“内存中的数据库/仓库”

`com.cinema.service.CinemaManager` 的定位：

- 管理四类核心数据：
  - `movies`（Map）
  - `rooms`（Map）
  - `shows`（Map）
  - `users`（Map）
- 启动时 `loadData()` 从 MySQL 加载（如果 MySQL 可用）
- 如果没有数据则 `initializeDefaultData()` 填充演示数据
- 提供增删改查方法（addMovie/removeMovie/addShow/removeShow…）
- 每次修改后会调用 `saveMovies/saveShows/saveUsers...` 把变更写回数据库

为什么 Map 用 `ConcurrentHashMap`？

- 因为 Spring Boot Web 服务会并发处理多个请求
- 多线程读写同一个 Map 时需要线程安全

注意：`ConcurrentHashMap` 只能保证 Map 本身的并发安全，不保证你“业务逻辑整体”原子性（这属于并发进阶内容）。

### 6.2 BookingService：订票核心（锁座/订单/支付/退票）

`com.cinema.service.BookingService` 是最核心的业务类之一。

#### 6.2.1 关键特点：必须先注入定价策略

BookingService 的单例初始化分两步：

- `getInstance(new StandardPricing())`：第一次创建实例，并设置 `pricingStrategy`
- 之后才能 `getInstance()`（否则会抛 `IllegalStateException`）

这解释了为什么 `CinemaApplication` 启动时要先初始化它。

#### 6.2.2 订单数据结构

- 内存里用 `ConcurrentMap<String, Order> orders` 存所有订单
- 同时也会持久化到 MySQL（在 `saveOrder(order)` 等方法里）

#### 6.2.3 createOrder：创建订单（PENDING）

核心步骤：

1. 校验参数
2. 校验场次是否已开始（已开始不能下单）
3. 遍历 seatIds：
   - 找 seat
   - 检查 seat 是否 available
   - **用定价策略计算价格**，写入 seat.basePrice
   - `seat.lock()` 锁座
4. 创建 `Order(status=PENDING)`
5. 订单放入 orders Map，并挂到 user 上
6. 持久化订单 + 保存场次
7. **通过 WebSocket 广播 UPDATE**，通知所有正在选座的人刷新

#### 6.2.4 reserveOrder：预订（RESERVED + 15分钟锁定）

与 createOrder 类似，但：

- 订单状态是 `RESERVED`
- 会设置 `lockTime = now`
- 提供 `order.isExpired()`：超过 15 分钟自动视为过期

#### 6.2.5 processReservedOrderPayment：支付预订单

流程：

1. 必须是 `RESERVED`
2. 如果 `isExpired()`：调用 cancelOrder 释放座位，并抛异常提示过期
3. 支付成功：
   - 状态改 `PAID`
   - seat.sell()
   - 保存订单 + 保存场次
   - 通知显示/通知服务

#### 6.2.6 processPayment：支付普通订单（PENDING → PAID）

- 订单必须是 PENDING
- 成功则 `PAID` 并 seat.sell()
- 失败则 seat.unlock() 并抛 `PaymentFailedException`

#### 6.2.7 cancelOrder：取消/退款

这个方法统一处理：

- `PENDING/RESERVED` 取消 → `CANCELLED`
- `PAID` 退票 → `REFUNDED`

并且都会：

- 释放座位 `seat.unlock()`
- 保存订单、保存场次
- WebSocket 广播刷新

### 6.3 定价策略（Strategy Pattern）：StandardPricing

`com.cinema.strategy.StandardPricing` 实现了 `PricingStrategy`。

它做了三类计算：

1. 根据座位类型选不同基价
   - VIPSeat：`show.getVipPrice()`
   - DiscountSeat：`show.getDiscountPrice()`
   - Regular：`show.getBasePrice()`
2. 周末加价 20%
3. 晚场（18 点后）加价 15%
4. 最终价格保留两位小数

这是 OOP 课常见考点：**策略模式让“算法可替换”**。

---

## 7. 控制器层（Controller）：HTTP API 是怎么写出来的？

Spring MVC 的基本套路：

- `@RestController`：返回 JSON（不走视图模板）
- `@RequestMapping("/api/xxx")`：统一前缀
- `@GetMapping` / `@PostMapping` / `@DeleteMapping`
- `@RequestBody`：从请求体 JSON 解析对象
- `@PathVariable`：从 URL 路径取参数
- `@RequestParam`：从 query string 取参数

### 7.1 统一响应格式

很多 Controller 使用类似结构：

```json
{
  "success": true,
  "code": 200,
  "message": "获取成功",
  "data": ...
}
```

这样前端很好判断：

- `success` 决定走成功/失败逻辑
- `message` 用于提示
- `data` 才是业务数据

### 7.2 AuthController：登录/注册

前端请求：

- `POST /api/login`
- `POST /api/register`

关键点：

- 登录成功会返回 `userId`（后续下单必须带）
- `accessToken` 是模拟 token（前端用于保存会话）

### 7.3 MovieController：电影管理 + 评论

- `GET /api/movies`：获取所有电影（用 MovieDTO 避免循环引用）
- `GET /api/movies/{id}`：电影详情
- `POST /api/movies`：新增电影
- 评论相关接口在该 controller 内（你可以在文件里继续往下看）

“DTO 的意义”（新手重点）：

- 实体对象（Movie）可能包含 Show，Show 又引用 Movie
- 直接返回会产生循环引用，序列化会报错
- 所以用 `MovieDTO` 只挑必要字段返回

### 7.4 ShowController：场次与座位

- `GET /api/shows`：支持 `movieId` 过滤
- `GET /api/shows/{id}/seats`：返回座位图（seatId/type/status/price）
- `POST /api/shows`：管理员排片
- `DELETE /api/shows/{id}`：删除场次

座位返回里：

- `type` 来自 Seat 子类（VIPSeat/DiscountSeat/Regular）
- `status` 来自 Seat.status（available/locked/sold）
- `price` 来自 BookingService.calculateSeatPrice

### 7.5 BookingController：下单/支付/退票/查订单

- `POST /api/booking/create`：创建订单并锁座（RESERVED）
- `POST /api/booking/pay`：支付
- `POST /api/booking/refund`：退票
- `GET /api/booking/my-orders?userId=xxx`：查询我的订单

其中“我的订单”返回会把 Order 转成前端友好的结构：

- movieTitle/startTime/roomName/seats/totalAmount/status...

这是“后端面向前端的 DTO/VO 设计”常见实践。

### 7.6 ScreeningRoomController：影厅列表

- `GET /api/rooms`：返回 id/name/capacity

### 7.7 NotificationController：通知列表

- `GET /api/notice/list?userId=xxx`：查询某用户通知

### 7.8 AiChatController：AI 问答

- `POST /api/chat/ask`：把 message 发给 `AiService` 获取回答

---

## 8. WebSocket：为什么能“实时刷新座位”？

### 8.1 WebSocket 服务端：SeatWebSocketServer

`@ServerEndpoint("/ws/seats/{showId}")` 表示：

- 客户端可以连接：`ws://localhost:8081/ws/seats/SHOW-001`
- 连接成功后，服务端把该 session 放进 `showId` 对应的集合

数据结构：

- `Map<showId, Set<Session>>`（并发安全）

### 8.2 广播刷新：fireUpdate(showId, "UPDATE")

当下单/支付/取消/退票导致座位变化时，BookingService 会调用：

- `SeatWebSocketServer.fireUpdate(showId, "UPDATE")`

客户端收到 UPDATE 后（前端实现），通常做：

- 重新调用 `GET /api/shows/{showId}/seats`
- 刷新座位图

这是一种“事件通知 + 拉取最新数据”的经典设计。

### 8.3 Spring 中如何启用 @ServerEndpoint？

`com.cinema.config.WebSocketConfig` 注入了 `ServerEndpointExporter`：

- 它会自动扫描并注册 `@ServerEndpoint` 标注的类

没有这个 Bean，WebSocket 端点可能不会生效。

---

## 9. HTTP 响应/代理问题修复：拦截器在做什么？

### 9.1 HttpResponseInterceptor

它在每个 `/api/**` 请求进入 Controller 之前就设置响应头：

- CORS：`Access-Control-Allow-Origin: *`
- 允许的方法：GET/POST/PUT/DELETE/OPTIONS
- content-type：`application/json;charset=UTF-8`
- 关闭 content-encoding（帮助避免某些代理的 chunk/gzip 问题）

并在 afterCompletion 里 `flushBuffer()`，确保响应写完。

### 9.2 WebMvcConfig 注册拦截器

`WebMvcConfig` 把拦截器挂载到 `/api/**`：

- 这样所有 API 都会统一带上这些响应头

### 9.3 HttpResponseConfig

设置默认 ContentType 为 JSON，并做 content negotiation 规则控制。

这三者配合：主要是为了解决开发环境下的代理/编码兼容问题。

---

## 10. 异常体系：为什么要自定义异常？

项目的异常在 `com.cinema.exception`：

- `InvalidBookingException`：参数无效、场次已开始等业务不合法
- `SeatNotAvailableException`：座位不存在/已占用
- `PaymentFailedException`：支付失败

新手要掌握的点：

- **异常是“业务失败”的一种表达方式**
- Service 抛异常 → Controller catch → 返回 `success=false` + message
- 这样前端能看到明确原因

---

## 11. 一个请求的完整链路（举例：创建订单/锁座）

以 `POST /api/booking/create` 为例：

### 11.1 请求进入 Spring

1. Tomcat 线程接收 HTTP 请求
2. Spring MVC 根据 URL + 方法，找到 `BookingController.createOrder`
3. Spring 把 JSON 请求体解析成 `BookingRequest`（靠 `@RequestBody`）

### 11.2 Controller 做“轻逻辑”

Controller 主要做：

- 调 Service
- catch 异常
- 拼装统一响应（success/code/message/data）

### 11.3 Service 做“重逻辑”（规则、状态、锁座）

BookingService.reserveOrder：

- 校验 user/show
- 校验 seat 可用
- 计算价格
- `seat.lock()`
- 创建 Order（RESERVED）
- 保存订单
- 保存 shows（把座位状态写回 DB）

### 11.4 Storage 写数据库

MySQLDataStorage 最终执行 `INSERT/UPDATE`：

- orders 表：订单基本信息
- order_seats：座位关联
- shows/seats：座位状态变化

### 11.5 返回响应给前端

Controller 返回 Map → Spring 自动序列化成 JSON → 发回浏览器。

---

## 12. 并发与“锁座”的现实意义（理解即可）

### 12.1 为什么需要锁座？

如果两个用户同时点同一个座位：

- 如果不锁座：可能产生“双卖”
- 通过 seat.lock()：第一个人锁住后，第二个人会检测到“不可用”

### 12.2 本项目的锁座是“内存状态 + 数据库存储”

- 内存：Seat.status 变为 LOCKED
- 持久化：保存 shows/seats 后写进 MySQL

注意（给你一个正确的工程思维）：

- 真正严谨的并发控制，通常需要“数据库层事务 + 行锁/乐观锁”等
- 本项目作为课程项目，用 Seat.status + 业务校验实现，逻辑清晰、便于展示 OOP 设计

---

## 13. 新手实操：如何验证后端接口？

### 13.1 先初始化数据库（可选，但建议）

1. 确保 MySQL 启动
2. 设置环境变量 `DB_PASSWORD`
3. 运行 `DatabaseInitializer`（IDE 右键运行 main）

### 13.2 启动后端

- 运行 `CinemaApplication`（Spring Boot）
- 看到 8081 启动成功日志

### 13.3 用浏览器/工具测试接口

你可以用 Postman 或 curl 测试：

- 登录：POST `/api/login`
- 电影列表：GET `/api/movies`
- 场次：GET `/api/shows?movieId=MOV-001`
- 座位：GET `/api/shows/SHOW-001/seats`
- 下单：POST `/api/booking/create`
- 支付：POST `/api/booking/pay`

如果你想，我也可以帮你写一份“Postman 测试集合步骤”放进文档里。

---

## 14. 你作为 Java 课程作业，最该会讲的 10 个点（答辩友好）

1. 为什么用 Spring Boot（快速搭建 REST API）
2. Controller/Service/Storage 分层的意义（职责分离）
3. Model 建模（Movie/Show/Seat/Order/User 的关系）
4. 策略模式（PricingStrategy，可替换算法）
5. 单例初始化问题（BookingService 需要先注入策略）
6. 锁座状态机（SeatStatus）
7. 订单状态机（OrderStatus + 15 分钟过期）
8. JDBC 批处理（executeBatch 提升性能）
9. WebSocket 推送（广播 UPDATE + 前端拉取刷新）
10. 统一响应格式（前后端协作更稳定）

---

## 15. 关键后端文件索引（方便你去看源码）

- 启动入口：`src/main/java/com/cinema/CinemaApplication.java`
- 控制器：`src/main/java/com/cinema/controller/*Controller.java`
- 业务核心：
  - `src/main/java/com/cinema/service/CinemaManager.java`
  - `src/main/java/com/cinema/service/BookingService.java`
- 数据库连接：`src/main/java/com/cinema/storage/SimpleDatabaseConnection.java`
- 数据持久化：`src/main/java/com/cinema/storage/MySQLDataStorage.java`
- WebSocket：`src/main/java/com/cinema/ws/SeatWebSocketServer.java`
- 定价策略：`src/main/java/com/cinema/strategy/StandardPricing.java`
- 配置：`src/main/java/com/cinema/config/*`
- 数据库脚本：`src/main/resources/schema.sql`
- 数据库配置：`src/main/resources/config.properties`

---

如果你希望我再“更答辩化”，我可以把第 14 节扩写成：
- 每个点 1-2 分钟讲稿
- 配一张你们项目的类图/流程图引用（你们 docs 里有 puml）
- 加上常见追问（例如：为什么订单要 order_seats 表？为什么要 DTO？）
