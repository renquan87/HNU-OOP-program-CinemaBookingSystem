# 电影院订票系统 - 助教提问预测与答题指南

> 基于三篇详细文档分析，预测助教最有可能问的问题及应对策略。按难度分类和提问概率排列。

---

## 目录
1. [必考问题（高概率/基础）](#必考问题高概率基础)
2. [常考问题（中概率/设计）](#常考问题中概率设计)
3. [深层问题（低概率/追问）](#深层问题低概率追问)
4. [快速应答卡](#快速应答卡)

---

## 必考问题（高概率/基础）

### Q1：能否简述一下你们项目的整体架构？

**助教的真实意图：**
- 检查你是否理解分层思想
- 看你能否用专业术语组织答案
- 判断你对项目认知深度

**推荐答法（1-2 分钟）：**

```
我们项目是典型的 MVC 分层架构：

1️⃣ 前端层（Vue 3 + TypeScript）
   • 用户界面展示和交互
   • 通过 HTTP 调用后端 API
   • 用 Pinia 管理全局数据（用户信息等）

2️⃣ 后端层（Spring Boot MVC）
   • Controller：接收 HTTP 请求，校验参数
   • Service：实现业务逻辑（订票规则、锁座、支付）
   • Storage/DAO：调用 JDBC 读写 MySQL

3️⃣ 数据库（MySQL）
   • 9 张表存储：电影、场次、座位、订单、用户等

通信方式：前端通过 /api 路由调用后端 REST API，
后端返回统一格式的 JSON 响应。
```

**加分点：** 主动提到"代理""WebSocket""状态机"等关键词。

---

### Q2：你们项目里订座的完整流程是什么？（从点击座位到支付成功）

**助教的真实意图：**
- 检查你对核心业务流程的理解
- 看你是否理解锁座机制
- 判断你代码阅读能力

**推荐答法（2-3 分钟）：**

```
座位选择 → 下单 → 锁座 → 预订 → 支付 的完整过程：

1️⃣ 前端：用户登录后进入电影列表，选择电影 → 快速购票

2️⃣ 前端：打开座位弹窗，调用 GET /api/shows/{showId}/seats
   后端返回：座位列表（包括状态：可用/已锁/已售）
   前端：显示座位图，用户点击选座

3️⃣ 前端：用户点击"下单"，调用 POST /api/booking/create
   请求体：{ showId, seatIds: ["1-1", "1-2"], userId }

4️⃣ 后端 BookingService.reserveOrder()：
   ✓ 校验场次是否存在、未开始
   ✓ 校验座位是否可用（AVAILABLE）
   ✓ 使用 PricingStrategy 计算每个座位价格
   ✓ 座位状态改为 LOCKED（内存 + 数据库）
   ✓ 创建 Order（状态=RESERVED，记录锁定时间）
   ✓ 返回订单信息到前端

5️⃣ 前端：显示"支付"按钮，用户点击

6️⃣ 后端 BookingService.processReservedOrderPayment()：
   ✓ 检查订单是否过期（>15分钟 → 失败）
   ✓ 执行支付逻辑
   ✓ 座位改为 SOLD
   ✓ 订单改为 PAID
   ✓ WebSocket 广播 UPDATE 通知其他在线用户刷新

7️⃣ 前端：收到 WebSocket UPDATE → 重新拉取座位列表 → 刷新显示

整个过程中的关键点：
• 座位锁定防止超卖
• 15 分钟过期机制防止长时间占座
• WebSocket 实时推送保证多人选座时 UI 同步
```

**加分点：** 
- 提到"SeatStatus.LOCKED""OrderStatus.RESERVED"等专业词汇
- 说明为什么要锁座（防止双卖）
- 提到 15 分钟过期的场景

**可能的追问：**
- Q：为什么要锁座？不锁行不行？
  A：不锁的话，两个用户同时点同一个座位，都可能创建订单，导致超卖。
  
- Q：如果用户选座后15分钟没支付会怎样？
  A：订单状态变为 EXPIRED，座位自动解锁变回 AVAILABLE，其他用户可以选购。

---

### Q3：为什么要分前端和后端？直接写一个单体不行吗？

**助教的真实意图：**
- 检查你的架构思维
- 看你是否理解关注点分离
- 判断你工程化能力

**推荐答法（1-2 分钟）：**

```
分前后端的好处：

1️⃣ 关注点分离：
   • 前端专注 UI 展示、用户交互
   • 后端专注业务逻辑、数据管理
   • 各自职责清晰，易于维护

2️⃣ 独立开发与并行测试：
   • 前端可以用 mock API 先开发
   • 后端可以用 Postman 先测试
   • 不需要等对方完成

3️⃣ 技术栈灵活：
   • 前端用 Vue 3，可以随时换成 React
   • 后端用 Spring Boot，可以换成其他框架
   • 只要保持 API 契约不变

4️⃣ 部署灵活：
   • 前端打包后是静态文件，可以上 CDN
   • 后端可以单独扩容、升级
   • 不会互相影响

5️⃣ 安全性：
   • 前端校验只是用户体验
   • 后端必须再校验一遍（业务规则不能在前端实现）
   • 例如：订票时必须在后端检查座位是否真的可用

如果写单体的话，上面所有优势都失去了。
```

**加分点：** 提到"API 契约""后端校验"等概念。

---

### Q4：后端是如何初始化的？为什么 CinemaApplication 里有那些单例初始化？

**助教的真实意图：**
- 检查你对 Spring Boot 生命周期的理解
- 看你是否真的读过项目代码
- 判断你对单例模式的理解

**推荐答法（1-2 分钟）：**

```
项目用了"遗留的单例设计"（传统 Java），而 Spring Boot 是现代框架。
两种思想碰撞，需要手动协调初始化顺序。

启动流程：

1️⃣ JVM 启动 main() 方法

2️⃣ 在 Spring Boot 启动前，手动初始化单例：
   SimpleDatabaseConnection.getInstance(dbPassword)
   ↓
   BookingService.getInstance(new StandardPricing())
   ↓
   CinemaManager.getInstance()

3️⃣ 单例初始化干什么：
   • SimpleDatabaseConnection：加载数据库配置，建立连接
   • BookingService：注入定价策略（PricingStrategy）
   • CinemaManager：从 MySQL 加载电影/影厅/场次/用户数据
     （如果 MySQL 不可用，用默认测试数据）

4️⃣ 然后启动 Spring Boot：
   SpringApplication.run(CinemaApplication.class, args)

5️⃣ Spring Boot 启动后：
   • 注册 Controller
   • 启用 WebSocket
   • 开始监听 8081 端口

为什么不用 Spring 的 @Service/@Component 管理这些类？
→ 因为这些类的 getInstance() 方法参数不一样
→ Spring 自动注入无法满足
→ 所以手动初始化
→ 这是"旧代码与新框架整合"的常见做法
```

**加分点：** 
- 解释为什么要手动初始化（Spring 无法自动满足）
- 提到"DatabaseInitializer"的作用（可选初始化数据库）

**可能的追问：**
- Q：如果数据库连接失败会怎样？
  A：CinemaManager.loadData() 会捕获异常，然后调用 initializeDefaultData() 用内存数据。

---

### Q5：什么是 WebSocket？为什么要用 WebSocket？

**助教的真实意图：**
- 检查你是否理解实时通信
- 看你对项目中 WebSocket 用途的理解
- 判断你的知识广度

**推荐答法（1 分钟）：**

```
HTTP vs WebSocket 对比：

HTTP（传统）：
• 请求-响应模式
• 浏览器发起请求 → 服务器响应 → 连接关闭
• 服务器无法主动推送

WebSocket（实时）：
• 连接建立后，双向通信
• 服务器可以随时给客户端发消息
• 适合实时场景

我们项目的用途：
当一个用户选座/支付时，我们通过 WebSocket 通知其他在线用户：
"座位状态改变了，请刷新"

具体流程：
1. 用户A/B 都在看同一场电影的座位图
2. 用户A 点击座位 1-1 并下单（座位锁定）
3. 后端 BookingService 调用 SeatWebSocketServer.fireUpdate(showId)
4. WebSocket 服务器向所有连接到该 showId 的客户端广播 UPDATE
5. 用户B 收到 UPDATE 消息
6. 用户B 的前端重新调用 GET /api/shows/{showId}/seats
7. 用户B 的座位图刷新，看到座位 1-1 已锁定

好处：
• 不需要用户手动刷新页面
• 多人选座时能看到实时状态
• 提升用户体验
```

**加分点：** 提到"双向通信""广播"等概念。

---

## 常考问题（中概率/设计）

### Q6：订单有哪些状态？为什么要这样设计？

**助教的真实意图：**
- 检查你是否理解状态机设计
- 看你对业务的理解深度
- 这是面向对象设计的常见考点

**推荐答法（2 分钟）：**

```
订单状态设计（OrderStatus）：

┌─────────┐
│ PENDING │ ← 刚创建，等待支付
└────┬────┘
     │ 支付成功
     ▼
┌─────────┐
│  PAID   │ ← 支付完成，订单生效
└─────────┘

或者：

┌──────────┐
│RESERVED  │ ← 预留中（锁座）
└────┬─────┘
     │ 支付成功
     ▼
┌─────────┐
│  PAID   │
└─────────┘

任何时刻都可以：
  PENDING/RESERVED/PAID ──取消──> CANCELLED
  PAID ──退款──> REFUNDED
  RESERVED ──超过15分钟──> EXPIRED

设计原因：

1️⃣ 区分订单生命周期的不同阶段
   • PENDING：还没钱，容易被取消
   • PAID：已确认，座位卖出
   • CANCELLED/REFUNDED：已结束

2️⃣ 防止业务错误
   • 只有 PENDING 能支付成功
   • 只有 RESERVED 能进行"预留支付"
   • 只有 PAID 能退款
   • 如果状态不对，直接拒绝操作

3️⃣ 15分钟过期机制
   • RESERVED 状态下，15分钟未支付则 EXPIRED
   • 目的：防止用户长时间占座不买票
   • 座位自动解锁，供其他人购买

4️⃣ 对账与统计
   • 财务系统可以按状态统计收入
   • 运营系统可以按状态分析用户行为
```

**加分点：** 
- 画出状态转移图
- 解释 15 分钟过期的业务价值

---

### Q7：讲讲定价策略（Pricing Strategy）。为什么要用策略模式？

**助教的真实意图：**
- 这是 OOP 课的**经典设计模式考点**
- 检查你是否理解策略模式的作用
- 看你能否举例说明模式的价值

**推荐答法（2 分钟）：**

```
定价规则（StandardPricing）：

基础价格 × 座位类型系数 × 时间系数 = 最终价格

座位类型：
• VIPSeat：show.getVipPrice()（例如 100 元）
• DiscountSeat：show.getDiscountPrice()（例如 30 元）
• RegularSeat：show.getBasePrice()（例如 50 元）

时间系数：
• 周末（周五-周日）：× 1.2（+20%）
• 晚场（18:00 后）：× 1.15（+15%）
• 两个都符合：× 1.2 × 1.15 = 1.38（+38%）

最终精确到两位小数：
Math.round(price * 100) / 100.0

为什么用策略模式？

❌ 不用的话（硬编码）：
   public double calculate(Seat seat, Show show) {
       if (seat instanceof VIPSeat) {
           // VIP 价格逻辑
       } else if (seat instanceof DiscountSeat) {
           // 优惠票逻辑
       }
       // ... 40 行代码
   }
   问题：
   • 代码耦合度高
   • 如果要改价格策略，得修改这个方法
   • 如果有多套定价策略（淡季/旺季/学生票），代码爆炸

✅ 用策略模式（接口 + 实现类）：
   interface PricingStrategy {
       double calculate(Seat seat, Show show);
   }
   
   class StandardPricing implements PricingStrategy {
       // 定价逻辑
   }
   
   class StudentPricing implements PricingStrategy {
       // 学生票逻辑（可能折扣更大）
   }

   BookingService bookingService = 
       new BookingService(new StandardPricing());

好处：
1️⃣ 新增策略不需要修改现有代码
2️⃣ 可以在运行时切换策略
3️⃣ 容易测试：mock 不同策略类
4️⃣ 符合开闭原则：对扩展开放，对修改关闭

真实场景：
假如这家电影院想：
• 工作日便宜点吸引上班族 → 新建 WorkdayPricing
• 学生证可打折 → 新建 StudentPricing
• 团购便宜点 → 新建 GroupPricing

传统做法：改 calculate 方法，测试风险大
策略模式：新建类，BookingService 注入新策略，零风险
```

**加分点：** 
- 代码示例对比（一定要有）
- 提到"开闭原则"等 OOP 原则
- 举实际例子（工作日/学生/团购）

---

### Q8：为什么要用 DTO（数据传输对象）？

**助教的真实意图：**
- 检查你对 OOP 与系统设计的理解
- 看你是否知道"数据隔离"的重要性

**推荐答法（1-2 分钟）：**

```
DTO（Data Transfer Object）在项目里的用处：

场景 1：电影对象的循环引用

实体对象 Movie：
class Movie {
    String id;
    String title;
    List<Show> shows;  // 一部电影有多场次
}

实体对象 Show：
class Show {
    String id;
    Movie movie;      // 每场次指向一部电影
    // ... 其他字段
}

问题：Movie 里有 List<Show>，Show 里又有 Movie
       → 无限循环引用
       → JSON 序列化报错（Stack Overflow）

解决方案：用 MovieDTO，只包含必要字段

class MovieDTO {
    String id;
    String title;
    // ❌ 不包含 shows，切断循环引用
}

API 返回时用 DTO 代替实体对象。

场景 2：信息隐藏

实体对象 User：
class User {
    String id;
    String username;
    String password;     // ❌ 不能暴露给前端
    String email;
    boolean isAdmin;     // ❌ 前端不需要知道是不是管理员
}

DTO 只暴露安全字段：
class UserDTO {
    String id;
    String username;
    String email;
    // ❌ password 和 isAdmin 都没有
}

好处：
• 前端无法猜测/利用隐藏字段
• 即使接口被黑客逆向，也拿不到敏感信息

场景 3：版本兼容性

假如一个月后，Movie 新增了字段 `director`。

如果直接返回 Movie 对象：
• 旧版本前端：可能崩溃（无法解析新字段）
• 新版本前端：期望新字段

如果用 MovieDTO：
• 可以新建 MovieDTOv2，包含 director
• 旧版本前端 → 返回 MovieDTO（没有 director）
• 新版本前端 → 返回 MovieDTOv2（有 director）
• API 版本化管理

总结：
DTO = 前端与后端通信的"契约"
不是实体对象的完整复制，而是精心设计的数据结构
```

**加分点：** 具体例子（电影循环引用、隐藏密码等）。

---

### Q9：MySQL 数据库是如何持久化的？为什么不用 Hibernate/JPA？

**助教的真实意图：**
- 检查你对 JDBC 与 ORM 框架的理解
- 看你能否解释"为什么要用原生 JDBC"

**推荐答法（1-2 分钟）：**

```
项目用的是原生 JDBC，而不是 Hibernate/JPA。

JDBC 的流程（原生）：
1. 获取连接：DriverManager.getConnection(url, user, password)
2. 创建语句：conn.prepareStatement(sql)
3. 设参数：stmt.setString(1, "value")
4. 执行：stmt.executeUpdate() 或 executeQuery()
5. 处理结果：ResultSet rs = stmt.getResultSet()
6. 关闭：rs.close(), stmt.close(), conn.close()

项目里 MySQLDataStorage 就是这样做的：

public void saveMovies(List<Movie> movies) {
    String sql = "INSERT INTO movies VALUES(...) 
                  ON DUPLICATE KEY UPDATE ...";
    
    try (Connection conn = SimpleDatabaseConnection.getConnection()) {
        conn.setAutoCommit(false);  // 开启事务
        
        try (PreparedStatement stmt = conn.prepareStatement(sql)) {
            for (Movie m : movies) {
                stmt.setString(1, m.getId());
                stmt.setString(2, m.getTitle());
                // ... 设置其他字段
                stmt.addBatch();  // 批处理
            }
            stmt.executeBatch();  // 一次执行所有
        }
        conn.commit();  // 提交事务
    } catch (SQLException e) {
        // 异常处理
    }
}

为什么不用 Hibernate/JPA？

Hibernate 优点：
• 自动 SQL 生成
• ORM 映射自动化
• 代码少

Hibernate 缺点（为什么项目不用）：
1️⃣ 学习曲线陡峭
   • 配置复杂（XML 或注解）
   • 调试困难（ORM 生成的 SQL 你看不到）
   • 新手容易掉坑

2️⃣ 性能不确定
   • Hibernate 生成的 SQL 可能不是最优
   • 批量操作需要特殊配置
   • 项目需要批处理提升性能

3️⃣ 对于课程项目不必要
   • 项目不大，表不多
   • SQL 相对简单
   • 原生 JDBC 够用，而且更直接

4️⃣ 这是学习的机会
   • 课程要求理解"如何读写数据库"
   • 用 JDBC 能更深入理解 SQL
   • 用 Hibernate 就是"黑盒"调用

我们项目的做法：
• 批处理：executeBatch()，性能好
• 事务管理：setAutoCommit(false) + commit()
• 对象映射：手动从 ResultSet 组装对象
• 简单高效，适合课程项目

如果是生产环境，也许会用 MyBatis 或 JPA
（它们在 JDBC 和 Hibernate 之间取平衡）
```

**加分点：** 提到"批处理""事务"等 JDBC 高级特性。

---

### Q10：怎样防止"超卖"（两个用户同时买同一个座位）？

**助教的真实意图：**
- 这是**并发编程**的经典问题
- 检查你的并发思维
- 看你对项目锁座机制的理解

**推荐答法（1-2 分钟）：**

```
超卖场景：
时间   用户A              用户B
T1    查询座位 1-1 可用   
T2                       查询座位 1-1 可用
T3    下单，创建 Order1   
T4                       下单，创建 Order2
T5    支付成功，座位售出   
T6                       支付成功，座位售出
结果：同一个座位卖给了两个用户！❌

我们的防御机制（分三层）：

1️⃣ 内存层（Java）：ConcurrentHashMap + Seat 状态
   • BookingService 维护 Order Map：ConcurrentHashMap
   • 每个 Seat 有状态：AVAILABLE/LOCKED/SOLD
   • 下单时先 seat.lock()，改变状态
   
   伪代码：
   if (seat.getStatus() == AVAILABLE) {
       seat.lock();  // 改为 LOCKED
       // ... 创建 Order
   }

2️⃣ 数据库层（MySQL）：持久化座位状态
   • 座位状态（available/locked/sold）存进 MySQL
   • Show 和 order_seats 表记录 booking 关系
   
   SQL：
   UPDATE shows SET seats_json='...' 
   WHERE id = 'SHOW-001'

3️⃣ 再验证（防止未来读到旧数据）
   • 支付前再检查一次座位状态
   • processPayment 时验证座位状态

整体逻辑：
┌──────────────────────────────────┐
│ 用户A、B 同时请求                  │
└──────────────┬───────────────────┘
               │
               ▼
┌──────────────────────────────────┐
│ BookingService.reserveOrder()    │
│ 1. 检查 seat.status == AVAILABLE │
│ 2. 立即改为 LOCKED（原子操作）    │
│ 3. 创建 Order(RESERVED)          │
│ 4. 保存到 MySQL                   │
└──────────────┬───────────────────┘
               │
       ┌───────┴────────┐
       ▼                ▼
    User A         User B
  seat = LOCKED  seat = LOCKED
  返回成功        返回：座位已锁定 ❌

原子性保证：
• "检查可用 + 改锁定" 这两步在内存中是快速的
• MySQL 持久化后，即使服务器崩溃也能恢复
• 对于课程项目来说，这种方式足够

真正的"分布式锁"（生产环境）：
• 用 Redis + Lua 脚本
• 或数据库行锁（SELECT ... FOR UPDATE）
• 或 MQ 排队
但那是更高阶的内容。

我们项目的做法：
✓ 用内存状态 + 数据库持久化
✓ 检查可用性在服务端（不信任前端）
✓ 下单时立即锁座
✓ 15 分钟后自动解锁（防止长期占座）
```

**加分点：** 
- 时间线说明超卖过程
- 提到三层防御
- 对比生产环境做法（Redis/行锁）

---

## 深层问题（低概率/追问）

### Q11：前端怎么知道座位状态变了？（WebSocket 机制）

**类型：** 深层理解追问

**推荐答法（1 分钟）：**

```
过程：
1. 用户A/B 都在选座，都通过 ws://localhost:8081/ws/seats/SHOW-001
   连接到 WebSocket 服务器

2. 用户A 下单 → BookingService.reserveOrder()
   → 座位状态改为 LOCKED
   → 调用 SeatWebSocketServer.fireUpdate(showId, "UPDATE")

3. WebSocket 服务器广播给所有连接到 SHOW-001 的客户端：
   收件人：用户A 的浏览器、用户B 的浏览器
   消息：{ type: "UPDATE", showId: "SHOW-001" }

4. 用户B 的前端收到 UPDATE 消息：
   → 调用 GET /api/shows/SHOW-001/seats（拉取最新座位状态）
   → 显示最新的座位图（包括用户A 锁定的座位）

为什么这样设计：
• WebSocket 只负责"通知有变化"
• 具体数据还是通过 HTTP 请求拉取
• 好处：不需要推送整个座位列表（数据量大）
        只推送一个 UPDATE 通知（数据量小）
        前端再决定是否拉取最新数据
```

---

### Q12：为什么前端需要登录？登录后保存的 userId 有什么作用？

**类型：** 业务逻辑追问

**推荐答法（1 分钟）：**

```
登录流程：
1. 用户输入用户名 + 密码
2. 前端调用 POST /api/login
3. 后端校验密码（实际项目应该加密，这里简化了）
4. 成功返回 { userId: "USER-001", token: "xxx" }
5. 前端保存到 Pinia store 和 localStorage

userId 的作用：
• 标识当前用户（防止匿名用户）
• 创建订单时必须带 userId（后端知道是谁下单的）
• 查询"我的订单"时需要 userId 过滤
• 如果没有 userId，订单就无法关联到用户身上

例子：
POST /api/booking/create
{
    showId: "SHOW-001",
    seatIds: ["1-1", "1-2"],
    userId: "USER-001"  ← 后端通过这个找到对应的 User 对象
}

如果没有登录（userId 为空）：
后端会拒绝：{ success: false, message: "请先登录" }
```

---

### Q13：如果 MySQL 连接失败了会怎样？

**类型：** 容错机制追问

**推荐答法（1 分钟）：**

```
流程：
1. CinemaApplication.main() 启动
2. 尝试初始化 SimpleDatabaseConnection（连接 MySQL）
3. 如果失败（MySQL 没启动、密码错等）：
   → CinemaManager.loadData() 捕获异常
   → 调用 initializeDefaultData()
   → 用内存里的演示数据（3 部电影 + 几个用户）

4. Spring Boot 照样启动成功
5. 前端可以正常选座、购票（但数据是演示数据）

重启动画后，MySQL 恢复：
• 重启后端程序
• SimpleDatabaseConnection 重新连接
• loadData() 成功，从 MySQL 加载真实数据

这是一种"优雅降级"：
• 有数据库就用数据库
• 没有也不要崩溃，用演示数据
• 适合课程演示
```

---

### Q14：Pinia 状态管理的好处是什么？

**类型：** 前端架构追问

**推荐答法（1 分钟）：**

```
场景：userId 在多个页面都需要用到

不用 Pinia 的问题：
// 电影首页需要 userId
// 座位选择页需要 userId
// 订单页需要 userId
// ...

如果不用 Pinia，每个页面都要通过 props 层层传递
或者用 localStorage 自己管理

用 Pinia 的好处：
import { useUserStoreHook } from "@/store/modules/user"

// 任何页面都能直接：
const userStore = useUserStoreHook()
const userId = userStore.userId  // 直接读，不需要 props

修改 userId：
userStore.loginByUsername(username, password)

好处：
1. 全局可访问，不需要 props 传递
2. 自动持久化到 localStorage
3. 修改时只需要改一个地方，所有页面自动同步
4. 比 localStorage 更清晰、更安全
```

---

### Q15：你们项目有什么不足或者可以改进的地方？

**类型：** 自我反思追问

**推荐答法（1-2 分钟，显得成熟）：**

```
⚠️ 这是"能显得聪慧"的问题，一定要答！

不足之处：

1️⃣ 密码安全
   目前：用户密码存明文（或简单加密）
   改进：应该用 bcrypt/Argon2 加密，不可逆

2️⃣ 支付模拟
   目前：processPayment() 只是改状态，没有真的走支付通道
   改进：应该集成支付宝/微信支付 API

3️⃣ 并发控制不严格
   目前：用内存状态 + 数据库持久化
   改进：生产环境应该用数据库行锁或 Redis 分布式锁

4️⃣ 错误处理不完善
   目前：某些边界情况可能没考虑周全
   改进：增加单元测试，覆盖所有分支

5️⃣ 日志不够详细
   目前：关键操作没有日志记录
   改进：用 SLF4J + Logback，记录每次订单变化

6️⃣ 没有权限管理
   目前：没有区分普通用户 / 管理员权限
   改进：加上权限检查，防止用户操作不该操作的资源

7️⃣ WebSocket 没有认证
   目前：任何人都能连接 /ws/seats/{showId}
   改进：应该在握手时验证 token，防止伪造

8️⃣ 没有限流
   目前：一个人可以无限创建订单
   改进：加上限流（5 秒内最多 1 个订单）

话术建议：
"我们项目作为课程作业已经完整展示了核心业务逻辑。
但如果要做生产环境，我会重点关注：
（1）安全性：密码、支付、权限认证
（2）可靠性：并发控制、错误恢复
（3）可维护性：日志、监控、单元测试"
```

**加分点：** 
- 说出具体问题（不要笼统）
- 给出改进方案
- 显得有工程化思维

---

## 快速应答卡

> 来不及准备？快速查看这个应答卡。

### 架构类

| 问题 | 核心答案 | 时间 |
|------|--------|------|
| 整体架构？ | 前端 Vue 3 → 后端 Spring Boot → MySQL | 1 分钟 |
| 为什么分前后端？ | 关注点分离、独立测试、技术灵活 | 1 分钟 |
| 4 层是什么？ | Controller → Service → Storage → DB | 30 秒 |

### 业务类

| 问题 | 核心答案 | 时间 |
|------|--------|------|
| 购票流程？ | 选座 → 锁座 → 预订 → 支付 | 2 分钟 |
| 订单状态有哪些？ | PENDING/RESERVED/PAID/CANCELLED/EXPIRED | 1 分钟 |
| 怎样防超卖？ | 锁座（改状态）+ 数据库持久化 | 1 分钟 |
| 为什么要 15 分钟过期？ | 防止用户长期占座 | 30 秒 |

### 技术类

| 问题 | 核心答案 | 时间 |
|------|--------|------|
| WebSocket 干什么？ | 实时推送座位变化通知 | 30 秒 |
| 定价策略的意义？ | 策略模式，支持灵活扩展 | 1 分钟 |
| 为什么用 DTO？ | 避免循环引用、隐藏敏感信息 | 1 分钟 |
| 为什么用原生 JDBC？ | 简单透明、学习价值高 | 1 分钟 |

### 启动类

| 问题 | 核心答案 | 时间 |
|------|--------|------|
| 为什么要手动初始化单例？ | Spring 无法自动满足参数要求 | 1 分钟 |
| CinemaApplication 启动顺序？ | 连接 → BookingService → CinemaManager → Spring | 1 分钟 |
| MySQL 连接失败怎样？ | 用演示数据，不影响启动 | 30 秒 |

---

## 最后建议

### 📝 答辩现场 Tips

1. **不要背诵，要理解**
   - 助教能听出来你是在背还是理解
   - 如果说不出来，直接说"我理解的是..."然后停下

2. **用时间线和流程图**
   - 不要只说结论，要说"怎么一步步来的"
   - 画图、举例子，比纯文字更有说服力

3. **主动提到关键词**
   - "状态机""策略模式""WebSocket""并发""事务"
   - 助教听到这些词会认为你深入思考过

4. **准备追问反驳**
   - 助教可能问："这样做不安全啊？"
   - 你要能接住："生产环境这样做...课程项目这样做..."

5. **时间管理**
   - 必考问题（Q1-Q5）：准备 1-2 分钟的标准答案
   - 常考问题（Q6-Q10）：准备详细版本（备用）
   - 深层问题（Q11-Q15）：快速应答卡

### 🎯 重点背诵（必背）

如果时间紧张，至少背这些：

```
1. 整体架构（前中后）
2. 购票流程（选座→锁座→预订→支付）
3. 订单状态（PENDING/RESERVED/PAID/CANCELLED/EXPIRED）
4. 为什么要锁座（防超卖）
5. 策略模式（定价可扩展）
6. WebSocket（实时推送座位变化）
```

---

祝答辩顺利！🎬🎉
